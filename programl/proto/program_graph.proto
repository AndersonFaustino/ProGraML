// Protocol messages for program graphs.
//
// Copyright 2019-2020 the ProGraML authors.
//
// Contact Chris Cummins <chrisc.101@gmail.com>.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package programl;

option go_package = "programlpb";
option java_multiple_files = true;
option java_outer_classname = "ProgramGraphProto";
option java_package = "com.programl";

import "programl/third_party/tensorflow/features.proto";

// A program graph.
//
// Module -> Function -> Node
//
// Edges connect nodes, without an explicit scope.
message ProgramGraph {
  repeated Node node = 1;
  repeated Edge edge = 2;
  repeated Function function = 4;
  repeated Module module = 5;
  Features features = 6;
}

// A list of program graphs.
message ProgramGraphList {
  Features context = 1;
  repeated ProgramGraph graph = 2;
}

// Options used to generate a program graph.
message ProgramGraphOptions {
  // If set, the program graph builder will reject graphs where:
  //  1. A module contains no nodes.
  //  2. A function contains no nodes.
  //  3. A node is unnconnected.
  bool strict = 3;
  bool instructions_only = 1;
  bool ignore_call_returns = 2;
  int32 opt_level = 4;
  string ir_path = 10;
}

// Features describing a program.
message ProgramGraphFeatures {
  FeatureLists node_features = 1;
  FeatureLists edge_features = 2;
  FeatureLists function_features = 3;
  FeatureLists module_features = 4;
  Features features = 5;
}

// A list of program graphs.
message ProgramGraphFeaturesList {
  Features context = 1;
  repeated ProgramGraphFeatures graph = 2;
}

// A node represents an instruction, variable, or constant.
message Node {
  // The type of node.
  enum Type {
    INSTRUCTION = 0;
    VARIABLE = 1;
    CONSTANT = 2;
  }
  Type type = 1;
  // The text of a node. This is the raw representation of a node, such as the
  // contents of a statement, or the name of an identifier.
  string text = 2;
  // An index into the parent ProgramGraph message's function list indicating
  // the source function for this node.
  int32 function = 4;
  // For IRs with a basic block abstraction, this value can be used to group
  // nodes by the basic block that they are defined in. This value is optional,
  // and when set, is used to define an ID for the block. IDs should be unique
  // across the entire program, i.e. when two nodes have the same block, they
  // should also have the same function.
  int32 block = 7;
  Features features = 8;
}

// An edge in a program graph. A conformant edge must:
// * Have a flow type set.
// * Have source and target values that are indices into the parent
//   ProgramGraph message's node list.
// * Have a position of zero if the flow is CALL.
message Edge {
  // The edge flow type.
  enum Flow {
    CONTROL = 0;
    DATA = 1;
    CALL = 2;
  }
  Flow flow = 1;
  int32 position = 2;
  int32 source = 3;
  int32 target = 4;
  Features features = 5;
}

// Container to describe a program function.
message Function {
  // The name of the function.
  string name = 1;
  // The source module of the function, as an index into the parent ProgramGraph
  // message's module list.
  int32 module = 2;
  Features features = 3;
}

// Container for a program module.
message Module {
  // The name of the module.
  string name = 1;
  // Features describing the module.
  Features features = 2;
}
